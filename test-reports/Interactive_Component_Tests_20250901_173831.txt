
Running 8 tests using 1 worker

üé† Testing Carousel Deep Interactions...
  ‚úò  1 [chromium] ‚Ä∫ tests/interactive-components.spec.ts:19:7 ‚Ä∫ Interactive Components Deep Testing ‚Ä∫ Carousel Deep Interaction - Navigation, Indicators, and Autoplay (16.2s)
üé† Testing Carousel Deep Interactions...
  ‚úò  2 [chromium] ‚Ä∫ tests/interactive-components.spec.ts:19:7 ‚Ä∫ Interactive Components Deep Testing ‚Ä∫ Carousel Deep Interaction - Navigation, Indicators, and Autoplay (retry #1) (15.5s)
Console Warning: cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation
üìë Testing Tabs Deep Interactions...
Found 0 tabs
‚úÖ Keyboard navigation working
  ‚úì  3 [chromium] ‚Ä∫ tests/interactive-components.spec.ts:87:7 ‚Ä∫ Interactive Components Deep Testing ‚Ä∫ Tabs Deep Interaction - Switching, Content Updates, and State Management (1.6s)
Console Warning: At examples/src/dropdown_menu_examples.rs:101:69, you access a reactive_graph::signal::read::ReadSignal<alloc::string::String> (defined at examples/src/dropdown_menu_examples.rs:8:48) outside a reactive tracking context. This might mean your app is not responding to changes in signal values in the way you expect.

Here‚Äôs how to fix it:

1. If this is inside a `view!` macro, make sure you are passing a function, not a value.
  ‚ùå NO  <p>{x.get() * 2}</p>
  ‚úÖ YES <p>{move || x.get() * 2}</p>

2. If it‚Äôs in the body of a component, try wrapping this access in a closure: 
  ‚ùå NO  let y = x.get() * 2
  ‚úÖ YES let y = move || x.get() * 2.

3. If you‚Äôre *trying* to access the value without tracking, use `.get_untracked()` or `.with_untracked()` instead.
Console Warning: At examples/src/dropdown_menu_examples.rs:108:69, you access a reactive_graph::signal::read::ReadSignal<alloc::string::String> (defined at examples/src/dropdown_menu_examples.rs:8:48) outside a reactive tracking context. This might mean your app is not responding to changes in signal values in the way you expect.

Here‚Äôs how to fix it:

1. If this is inside a `view!` macro, make sure you are passing a function, not a value.
  ‚ùå NO  <p>{x.get() * 2}</p>
  ‚úÖ YES <p>{move || x.get() * 2}</p>

2. If it‚Äôs in the body of a component, try wrapping this access in a closure: 
  ‚ùå NO  let y = x.get() * 2
  ‚úÖ YES let y = move || x.get() * 2.

3. If you‚Äôre *trying* to access the value without tracking, use `.get_untracked()` or `.with_untracked()` instead.
Console Warning: At examples/src/dropdown_menu_examples.rs:115:69, you access a reactive_graph::signal::read::ReadSignal<alloc::string::String> (defined at examples/src/dropdown_menu_examples.rs:8:48) outside a reactive tracking context. This might mean your app is not responding to changes in signal values in the way you expect.

Here‚Äôs how to fix it:

1. If this is inside a `view!` macro, make sure you are passing a function, not a value.
  ‚ùå NO  <p>{x.get() * 2}</p>
  ‚úÖ YES <p>{move || x.get() * 2}</p>

2. If it‚Äôs in the body of a component, try wrapping this access in a closure: 
  ‚ùå NO  let y = x.get() * 2
  ‚úÖ YES let y = move || x.get() * 2.

3. If you‚Äôre *trying* to access the value without tracking, use `.get_untracked()` or `.with_untracked()` instead.
Console Warning: At examples/src/dropdown_menu_examples.rs:138:64, you access a reactive_graph::signal::read::ReadSignal<bool> (defined at examples/src/dropdown_menu_examples.rs:9:38) outside a reactive tracking context. This might mean your app is not responding to changes in signal values in the way you expect.

Here‚Äôs how to fix it:

1. If this is inside a `view!` macro, make sure you are passing a function, not a value.
  ‚ùå NO  <p>{x.get() * 2}</p>
  ‚úÖ YES <p>{move || x.get() * 2}</p>

2. If it‚Äôs in the body of a component, try wrapping this access in a closure: 
  ‚ùå NO  let y = x.get() * 2
  ‚úÖ YES let y = move || x.get() * 2.

3. If you‚Äôre *trying* to access the value without tracking, use `.get_untracked()` or `.with_untracked()` instead.
Console Warning: At examples/src/dropdown_menu_examples.rs:144:66, you access a reactive_graph::signal::read::ReadSignal<bool> (defined at examples/src/dropdown_menu_examples.rs:10:42) outside a reactive tracking context. This might mean your app is not responding to changes in signal values in the way you expect.

Here‚Äôs how to fix it:

1. If this is inside a `view!` macro, make sure you are passing a function, not a value.
  ‚ùå NO  <p>{x.get() * 2}</p>
  ‚úÖ YES <p>{move || x.get() * 2}</p>

2. If it‚Äôs in the body of a component, try wrapping this access in a closure: 
  ‚ùå NO  let y = x.get() * 2
  ‚úÖ YES let y = move || x.get() * 2.

3. If you‚Äôre *trying* to access the value without tracking, use `.get_untracked()` or `.with_untracked()` instead.
Console Warning: At examples/src/dropdown_menu_examples.rs:172:65, you access a reactive_graph::signal::read::ReadSignal<alloc::string::String> (defined at examples/src/dropdown_menu_examples.rs:11:40) outside a reactive tracking context. This might mean your app is not responding to changes in signal values in the way you expect.

Here‚Äôs how to fix it:

1. If this is inside a `view!` macro, make sure you are passing a function, not a value.
  ‚ùå NO  <p>{x.get() * 2}</p>
  ‚úÖ YES <p>{move || x.get() * 2}</p>

2. If it‚Äôs in the body of a component, try wrapping this access in a closure: 
  ‚ùå NO  let y = x.get() * 2
  ‚úÖ YES let y = move || x.get() * 2.

3. If you‚Äôre *trying* to access the value without tracking, use `.get_untracked()` or `.with_untracked()` instead.
Console Warning: At examples/src/dropdown_menu_examples.rs:179:65, you access a reactive_graph::signal::read::ReadSignal<alloc::string::String> (defined at examples/src/dropdown_menu_examples.rs:11:40) outside a reactive tracking context. This might mean your app is not responding to changes in signal values in the way you expect.

Here‚Äôs how to fix it:

1. If this is inside a `view!` macro, make sure you are passing a function, not a value.
  ‚ùå NO  <p>{x.get() * 2}</p>
  ‚úÖ YES <p>{move || x.get() * 2}</p>

2. If it‚Äôs in the body of a component, try wrapping this access in a closure: 
  ‚ùå NO  let y = x.get() * 2
  ‚úÖ YES let y = move || x.get() * 2.

3. If you‚Äôre *trying* to access the value without tracking, use `.get_untracked()` or `.with_untracked()` instead.
Console Warning: At examples/src/dropdown_menu_examples.rs:186:65, you access a reactive_graph::signal::read::ReadSignal<alloc::string::String> (defined at examples/src/dropdown_menu_examples.rs:11:40) outside a reactive tracking context. This might mean your app is not responding to changes in signal values in the way you expect.

Here‚Äôs how to fix it:

1. If this is inside a `view!` macro, make sure you are passing a function, not a value.
  ‚ùå NO  <p>{x.get() * 2}</p>
  ‚úÖ YES <p>{move || x.get() * 2}</p>

2. If it‚Äôs in the body of a component, try wrapping this access in a closure: 
  ‚ùå NO  let y = x.get() * 2
  ‚úÖ YES let y = move || x.get() * 2.

3. If you‚Äôre *trying* to access the value without tracking, use `.get_untracked()` or `.with_untracked()` instead.
Console Warning: At examples/src/dropdown_menu_examples.rs:193:65, you access a reactive_graph::signal::read::ReadSignal<alloc::string::String> (defined at examples/src/dropdown_menu_examples.rs:11:40) outside a reactive tracking context. This might mean your app is not responding to changes in signal values in the way you expect.

Here‚Äôs how to fix it:

1. If this is inside a `view!` macro, make sure you are passing a function, not a value.
  ‚ùå NO  <p>{x.get() * 2}</p>
  ‚úÖ YES <p>{move || x.get() * 2}</p>

2. If it‚Äôs in the body of a component, try wrapping this access in a closure: 
  ‚ùå NO  let y = x.get() * 2
  ‚úÖ YES let y = move || x.get() * 2.

3. If you‚Äôre *trying* to access the value without tracking, use `.get_untracked()` or `.with_untracked()` instead.
Console Warning: At examples/src/dropdown_menu_examples.rs:200:65, you access a reactive_graph::signal::read::ReadSignal<alloc::string::String> (defined at examples/src/dropdown_menu_examples.rs:11:40) outside a reactive tracking context. This might mean your app is not responding to changes in signal values in the way you expect.

Here‚Äôs how to fix it:

1. If this is inside a `view!` macro, make sure you are passing a function, not a value.
  ‚ùå NO  <p>{x.get() * 2}</p>
  ‚úÖ YES <p>{move || x.get() * 2}</p>

2. If it‚Äôs in the body of a component, try wrapping this access in a closure: 
  ‚ùå NO  let y = x.get() * 2
  ‚úÖ YES let y = move || x.get() * 2.

3. If you‚Äôre *trying* to access the value without tracking, use `.get_untracked()` or `.with_untracked()` instead.
üîΩ Testing DropdownMenu Deep Interactions...
Found 0 dropdown triggers
  ‚úò  4 [chromium] ‚Ä∫ tests/interactive-components.spec.ts:137:7 ‚Ä∫ Interactive Components Deep Testing ‚Ä∫ DropdownMenu Deep Interaction - Complex Menu Structures and Submenus (30.9s)
Console Warning: At examples/src/dropdown_menu_examples.rs:101:69, you access a reactive_graph::signal::read::ReadSignal<alloc::string::String> (defined at examples/src/dropdown_menu_examples.rs:8:48) outside a reactive tracking context. This might mean your app is not responding to changes in signal values in the way you expect.

Here‚Äôs how to fix it:

1. If this is inside a `view!` macro, make sure you are passing a function, not a value.
  ‚ùå NO  <p>{x.get() * 2}</p>
  ‚úÖ YES <p>{move || x.get() * 2}</p>

2. If it‚Äôs in the body of a component, try wrapping this access in a closure: 
  ‚ùå NO  let y = x.get() * 2
  ‚úÖ YES let y = move || x.get() * 2.

3. If you‚Äôre *trying* to access the value without tracking, use `.get_untracked()` or `.with_untracked()` instead.
Console Warning: At examples/src/dropdown_menu_examples.rs:108:69, you access a reactive_graph::signal::read::ReadSignal<alloc::string::String> (defined at examples/src/dropdown_menu_examples.rs:8:48) outside a reactive tracking context. This might mean your app is not responding to changes in signal values in the way you expect.

Here‚Äôs how to fix it:

1. If this is inside a `view!` macro, make sure you are passing a function, not a value.
  ‚ùå NO  <p>{x.get() * 2}</p>
  ‚úÖ YES <p>{move || x.get() * 2}</p>

2. If it‚Äôs in the body of a component, try wrapping this access in a closure: 
  ‚ùå NO  let y = x.get() * 2
  ‚úÖ YES let y = move || x.get() * 2.

3. If you‚Äôre *trying* to access the value without tracking, use `.get_untracked()` or `.with_untracked()` instead.
Console Warning: At examples/src/dropdown_menu_examples.rs:115:69, you access a reactive_graph::signal::read::ReadSignal<alloc::string::String> (defined at examples/src/dropdown_menu_examples.rs:8:48) outside a reactive tracking context. This might mean your app is not responding to changes in signal values in the way you expect.

Here‚Äôs how to fix it:

1. If this is inside a `view!` macro, make sure you are passing a function, not a value.
  ‚ùå NO  <p>{x.get() * 2}</p>
  ‚úÖ YES <p>{move || x.get() * 2}</p>

2. If it‚Äôs in the body of a component, try wrapping this access in a closure: 
  ‚ùå NO  let y = x.get() * 2
  ‚úÖ YES let y = move || x.get() * 2.

3. If you‚Äôre *trying* to access the value without tracking, use `.get_untracked()` or `.with_untracked()` instead.
Console Warning: At examples/src/dropdown_menu_examples.rs:138:64, you access a reactive_graph::signal::read::ReadSignal<bool> (defined at examples/src/dropdown_menu_examples.rs:9:38) outside a reactive tracking context. This might mean your app is not responding to changes in signal values in the way you expect.

Here‚Äôs how to fix it:

1. If this is inside a `view!` macro, make sure you are passing a function, not a value.
  ‚ùå NO  <p>{x.get() * 2}</p>
  ‚úÖ YES <p>{move || x.get() * 2}</p>

2. If it‚Äôs in the body of a component, try wrapping this access in a closure: 
  ‚ùå NO  let y = x.get() * 2
  ‚úÖ YES let y = move || x.get() * 2.

3. If you‚Äôre *trying* to access the value without tracking, use `.get_untracked()` or `.with_untracked()` instead.
Console Warning: At examples/src/dropdown_menu_examples.rs:144:66, you access a reactive_graph::signal::read::ReadSignal<bool> (defined at examples/src/dropdown_menu_examples.rs:10:42) outside a reactive tracking context. This might mean your app is not responding to changes in signal values in the way you expect.

Here‚Äôs how to fix it:

1. If this is inside a `view!` macro, make sure you are passing a function, not a value.
  ‚ùå NO  <p>{x.get() * 2}</p>
  ‚úÖ YES <p>{move || x.get() * 2}</p>

2. If it‚Äôs in the body of a component, try wrapping this access in a closure: 
  ‚ùå NO  let y = x.get() * 2
  ‚úÖ YES let y = move || x.get() * 2.

3. If you‚Äôre *trying* to access the value without tracking, use `.get_untracked()` or `.with_untracked()` instead.
Console Warning: At examples/src/dropdown_menu_examples.rs:172:65, you access a reactive_graph::signal::read::ReadSignal<alloc::string::String> (defined at examples/src/dropdown_menu_examples.rs:11:40) outside a reactive tracking context. This might mean your app is not responding to changes in signal values in the way you expect.

Here‚Äôs how to fix it:

1. If this is inside a `view!` macro, make sure you are passing a function, not a value.
  ‚ùå NO  <p>{x.get() * 2}</p>
  ‚úÖ YES <p>{move || x.get() * 2}</p>

2. If it‚Äôs in the body of a component, try wrapping this access in a closure: 
  ‚ùå NO  let y = x.get() * 2
  ‚úÖ YES let y = move || x.get() * 2.

3. If you‚Äôre *trying* to access the value without tracking, use `.get_untracked()` or `.with_untracked()` instead.
Console Warning: At examples/src/dropdown_menu_examples.rs:179:65, you access a reactive_graph::signal::read::ReadSignal<alloc::string::String> (defined at examples/src/dropdown_menu_examples.rs:11:40) outside a reactive tracking context. This might mean your app is not responding to changes in signal values in the way you expect.

Here‚Äôs how to fix it:

1. If this is inside a `view!` macro, make sure you are passing a function, not a value.
  ‚ùå NO  <p>{x.get() * 2}</p>
  ‚úÖ YES <p>{move || x.get() * 2}</p>

2. If it‚Äôs in the body of a component, try wrapping this access in a closure: 
  ‚ùå NO  let y = x.get() * 2
  ‚úÖ YES let y = move || x.get() * 2.

3. If you‚Äôre *trying* to access the value without tracking, use `.get_untracked()` or `.with_untracked()` instead.
Console Warning: At examples/src/dropdown_menu_examples.rs:186:65, you access a reactive_graph::signal::read::ReadSignal<alloc::string::String> (defined at examples/src/dropdown_menu_examples.rs:11:40) outside a reactive tracking context. This might mean your app is not responding to changes in signal values in the way you expect.

Here‚Äôs how to fix it:

1. If this is inside a `view!` macro, make sure you are passing a function, not a value.
  ‚ùå NO  <p>{x.get() * 2}</p>
  ‚úÖ YES <p>{move || x.get() * 2}</p>

2. If it‚Äôs in the body of a component, try wrapping this access in a closure: 
  ‚ùå NO  let y = x.get() * 2
  ‚úÖ YES let y = move || x.get() * 2.

3. If you‚Äôre *trying* to access the value without tracking, use `.get_untracked()` or `.with_untracked()` instead.
Console Warning: At examples/src/dropdown_menu_examples.rs:193:65, you access a reactive_graph::signal::read::ReadSignal<alloc::string::String> (defined at examples/src/dropdown_menu_examples.rs:11:40) outside a reactive tracking context. This might mean your app is not responding to changes in signal values in the way you expect.

Here‚Äôs how to fix it:

1. If this is inside a `view!` macro, make sure you are passing a function, not a value.
  ‚ùå NO  <p>{x.get() * 2}</p>
  ‚úÖ YES <p>{move || x.get() * 2}</p>

2. If it‚Äôs in the body of a component, try wrapping this access in a closure: 
  ‚ùå NO  let y = x.get() * 2
  ‚úÖ YES let y = move || x.get() * 2.

3. If you‚Äôre *trying* to access the value without tracking, use `.get_untracked()` or `.with_untracked()` instead.
Console Warning: At examples/src/dropdown_menu_examples.rs:200:65, you access a reactive_graph::signal::read::ReadSignal<alloc::string::String> (defined at examples/src/dropdown_menu_examples.rs:11:40) outside a reactive tracking context. This might mean your app is not responding to changes in signal values in the way you expect.

Here‚Äôs how to fix it:

1. If this is inside a `view!` macro, make sure you are passing a function, not a value.
  ‚ùå NO  <p>{x.get() * 2}</p>
  ‚úÖ YES <p>{move || x.get() * 2}</p>

2. If it‚Äôs in the body of a component, try wrapping this access in a closure: 
  ‚ùå NO  let y = x.get() * 2
  ‚úÖ YES let y = move || x.get() * 2.

3. If you‚Äôre *trying* to access the value without tracking, use `.get_untracked()` or `.with_untracked()` instead.
üîΩ Testing DropdownMenu Deep Interactions...
Found 0 dropdown triggers
